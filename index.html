<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <style>
    .reveal pre code {
      max-height: 550px;
    }

    .text-shadow {
      text-shadow: 2px 4px 3px rgba(0, 0, 0, 0.3) !important;
    }
  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Scope <br>&<br> Closures</h1>
      </section>

      <section>
        <section data-markdown>

          <textarea data-template>
          ## Scope
          Набор правил, которые определяют где и как искать переменную по ее имени <!-- .element: class="fragment" -->
          
          Область программы, в пределах которой идентификатор (имя) некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение <!-- .element: class="fragment" -->

          Note: Возможность хранить значения в переменных, а впоследствии получать эти значения - одна из фундаментальных парадигм почти
          всех языков программирования. Мы называем это состоянием программы. И без этого программы были бы не очень интересны и полезны,
          хотя они бы и выполняли какие-то действия. Но где эти переменные хранятся в программе? И как наша программа находит
          их, когда они ей нужны? -> Набор правил которые определяют где и как искать переменные мы называем областью видимости.
          -> Вообще у области видимости есть множество определений и вот еще одно из более строгих.
        </textarea>

        </section>

        <section>
          <p>Как переменные попадают в scope?</p>
          <img src="img/Compiler_time.png">

          <aside class="notes">
            JavaScript компилируемый язык, но исполняется он сразу после компиляции. Так вот во время компиляции, но перед тем, как сгенерировать
            код для выполнения Движком, компилятор привязывает переменные к областям видимости в которых они были объявлены.
            В данном случае была объявлена переменная 'a' и привязана к глобальной области видимости.
          </aside>
        </section>

        <section>
          <p>Как идентификаторы находятся в SCOPE?</p>
          <p class="fragment fade-up">LHS = RHS</p>
          <p class="fragment fade-up">LHS: &nbsp;<code>var a = 2;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>var a = b + c;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>console.log(a)</code></p>

          <aside class="notes">
            После этого генерируется код и исполняется Движком. Когда Движок наталкивается на переменную он ищет ее в скоупе. Поиск может
            осуществляться по двум разным правилам. -> Левосторонний (left hand side) и правосторонний поиск (right hand
            side). Но стороны относительно чего? Относительно оператора присваивания. Но вообще правосторонний поиск не всегда
            связан с оператором присваивания. Можно сказать он не-левосторонний. -> То есть левосторонний поиск осуществляется
            с целью присвоения значения в переменную, -> а правосторонний для возвращения значения переменной.
            </br>
          </aside>
        </section>

        <section>
          <p>Example</p>
          <pre><code data-trim data-noescape>
              function foo(a) {
                var b = a;
                return a + b;
              }
              
              var c = foo( 2 );
          </code></pre>

          <aside class="notes">
            Чтобы понять это лучше, давайте рассмотрим пример. В этом примере есть 3 LHS - 'var c' (объявление переменной c), 'a = 2'
            (а также скрытое присвоение значения аргументу a функции) и 'var b'. А также 4 RHS - 'foo(..)', '= a' , 'a +',
            '+ b'
          </aside>
        </section>

        <section data-background-image="img/building.jpg">
          <p class="text-shadow">Nested Scopes</p>

          <!-- TODO: поменять картинку -->
          <img width="600" height="370" src="img/lexical_scope.png" alt="lexical scope">

          <aside class="notes">
            В предыдущих примерах код был написан в глобальной области видимости, но областей видимости в программе обычно бывает множество
            и так же как функции или блоки могут быть вложенны в другие блоки или функции, области видимости вложенны в другие
            области видимости. И если переменная не была найдена в текущей области видимости, то движок будет искать ее во
            внешних областях видимости, пока не доберется до самой верхней, называемой глобальной. Хорошой метафорой может
            служить многоэтажное здание, в котором текущая область видимости это первый этаж и если мы не найдем переменную
            на этом этаже, то будем подниматься выше по этажам ищя ее, вплоть до последнего этажа, который и является глобальной
            областью видимости. В данном примере переменной b нет в области видимости фунции foo, поэтому Движок ищет (с
            помощью правостороеннего поиска, так как мы ищем переменную с целью вернуть ее значение) и находит ее в глобальной
            области видимости.
          </aside>
        </section>

        <section>
          <p>Errors ⛔️</p>
          <pre><code data-trim data-noescape>
              function foo(a) {
                console.log( a + b );
                b = a;
              }
              
              foo( 2 );
            </code></pre>
          <p class="fragment fade-up">RHS => <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up">LHS => leaked global variable</p>
          <p class="fragment fade-up">LHS + <code>'strict mode'</code>=> <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up"><code>"don't call me"()</code>=> <code><mark>TypeError</mark></code></p>

          <aside class="notes">
            Почему важен тип поиска переменной? Потому что эти два типа поиска ведут себя по разному в случае ошибки. Если переменная
            не была объявлена и не найдена ни в одной из верхних областей видимости, то в случае правостороннего поиска(RHS)
            это приведет к ошибки 'ReferenceError'. В случае левостороннего поиска (LHS) это приведет к объявлению переменной
            в глобальной области видимости. Это может привести к проблемам, которые сложно отлаживать. Чтобы застраховать
            нас от подобного поведения в ES5 была введена директива strict mode, которая ужесточает правила выполнения кода
            и в данном случае не даст создать переменную в глобальной области видимости, а закончит выполнение программы
            с ошибкой 'ReferenceError'. Если правосторонний поиск выполнился успешно, но мы попытались сделать с полученным
            значением что-то недопустимое, например вызвать как функцию значение не являющееся ей или обратились к свойсвам
            null или undefined, как будто-то они объекты, то мы получим ошибку TypeError и программа также прекратит выполнение.
            То есть понимая как ошибки выполнения связаны с типом поиска, мы можем легче находить и устранять баги.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h3>Type of Scopes</h3>
          <p>Lexical scope - ✍🏻 write-time</p>
          <p>Dynamyc scope - 🚀 runtime</p>

          <aside class="notes">
            JavaScript имеет лексическую область видимости. Это значит, что она основана на том, где переменные и блоки областей видимости
            были написаны самим автором кода. В противоположность этому существует концепция динамической области видимости.
            При таком подходе, не важно где автор написал функцию, а важно откуда она была вызвана во время исполнения кода.
            Такой подход используетмся например в bash скриптах.
          </aside>
        </section>

        <section>
          <h4>Cheating lexical 🚨</h4>
          <p class="fragment fade-up"><code>eval</code></p>
          <p class="fragment fade-up"><code>with</code></p>

          <aside class="notes">
            Но существуют способы взломать лексическую область видимости. Это можно сделать с помощью функции eval или ключевого слова
            with
          </aside>
        </section>

        <section>
          <h2><code>eval</code></h2>
          <pre><code data-trim data-noescape>
            function foo(str, a) {
              eval( str ); // cheating!
              console.log( a, b );
            }
            
            var b = 2;
            
            foo( "var b = 3;", 1 ); // 1 3
            </code></pre>

          <aside class="notes">
            Eval позволяет выполнять сроку с кодом, в которой может быть одно или несколько объявлений (переменных или функций). Строку
            кода конечно можно собирать программно, а не использовать фиксированный литерал, как в этом примере. Таким образом
            в этом снипите кода, Движок как обычно осуществляет поиск переменной в области видимости, не знаю, что она была
            взломана. Также стоит сказать, что директива 'strict mode' не аозволяет модифицировать область видимости в которой
            была исполнена eval.
          </aside>
        </section>

        <section>
          <h4><code>with</code></h4>
          <pre><code data-trim data-noescape>
            var obj = {
              a: 1,
              b: 2,
              c: 3
            };
            
            // долго писать
            obj.a = 2;
            obj.b = 3;
            obj.c = 4;
            
            // норм
            with (obj) {
              a = 3;
              b = 4;
              c = 5;
            }
            </code></pre>

          <aside class="notes">
            Можно сказать, что with используются для короткой записи переопределения свойств объекта. Но под капотом происходит нечто
            интересное.
          </aside>
        </section>

        <section>
          <h4><code>with</code></h4>
          <pre><code data-trim data-noescape>
            function foo(obj) {
              with (obj) {
                a = 2;
              }
            }
            
            var o1 = {
              a: 3
            };
            
            var o2 = {
              b: 3
            };
            
            foo( o1 );
            console.log( o1.a ); // 2
            
            foo( o2 );
            console.log( o2.a ); // undefined
            console.log( a ); // 2 -- Oops, leaked global!
            </code></pre>

          <aside class="notes">
            У нас есть два объекта "o1" и "o2". У одного есть свойство a, а у другого нет. Они передаются в функцию, где вызываются с
            with. Внутри блока with у нас происходит левосторонний поиск для переменной "а" и присвоение в нее значения "2".
            Но в итоге у объекта "o2" свойство "a" равно undefined, зато в глобальной области видимости у идентификатора
            "a" теперь есть значение 2. Это происходит потому что with использует переданный в него объект как совершенно
            новую лексическую область видимости, созданную из неоткуда. А свойства этого объекта считаются идентификаторами
            объявленными в этой области видимости. Таким образом для второго объекта присвоение в свойство "а" значения "2"
            не происходит, потому что в нем (если рассматривать его как область видимости) нет такого идентификатора и далее
            осуществляется привычный нам левосторонний поиск по областям видимости, который доходит до глобальной области
            видимости, так как в области видимости функции тоже нет такого идентификатора, и объявляет там идентификатор
            "а" (ну и затем присваевает в него "2"). При директиве "strict mode" полностью запрещен.
          </aside>
        </section>

        <section data-background-image="img/stop.jpg">
          <h3 class="text-shadow">Never use them</h3>

        </section>
        <aside class="notes">
          Почему это плохо? Простой ответ - производительность. Во время компиляции Движок JS осуществляет ряд оптимизаций, в том числе
          предопределяет где объявлены все переменные и функции. И так как он не может знать какую строку мы передадим в
          "eval" или с каким объектом мы вызовем "with", он не делает вообще никаких оптимизаций. Что очевидно ведет медленному
          выполнению кода. Поэтому никогда не стоит использовать eval и with.
        </aside>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Why scope?</h2>
          <p class="fragment fade-up">Principle of Least Privilege</p>
          <p class="fragment fade-up">Collision Avoidance</p>

          <aside class="notes">
            Для чего вообще нужен такой механизм, как область видимости? В JS область видимости в основном основана на функциях. Мы часто
            сначала объявляем функцию, а затем пишем в ней код. Но конечно можно поступать и наоборот, брать кусок кода и
            оборачивать его в функцию, скрывая таким образом переменные внутри функции и делая их недоступными за ее пределами.
            Такой подход использования скоупа дает нам несколько преимуществ. Первое, это соответствие принципу наименьшей
            привелегии, также называемого принципом наименьшего влияния или воздейстия. В соответсвии с этим принципом дизайн
            API для модуля или объекта должен раскрывать только то, что необходимо и скрывать все остальное. Второе преимущество
            позволяет избежать колизий или столкновений между двумя переменными с одинаковыми идентификаторами, но предназначенными
            для разного использования. Это может вести к непреднамеренной перезаписи значений этих переменных. Хорошим примером
            может служить добавление множества различных библиотек, в которых переменные и функции не спрятаны должным образом
            и соответственно могут перезаписывать друг друга. Чтобы этого не происходило можно использовать паттерн модуль,
            о котором я раскажу немного позже.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Functions As Scopes</h2>
          <pre><code data-trim data-noescape>
              var a = 2;
              
              function foo() {
              
                var a = 3;
                console.log( a ); // 3
              
              }
              foo();
              
              console.log( a ); // 2
              </code></pre>

          <aside class="notes">
            Итак мы используем функции, чтобы спрятать переменные. Но хотя этот пример работает, у него есть несколько недостатков. Мы
            объявили именованную функцию, что само по себе загрязняет внешнюю область видимости. Во вторых эту функцию нужно
            вызвать, чтобы выполнить код.
          </aside>
        </section>

        <section>
          <h2>IIFE</h2>
          <p>Immediately Invoked Function Expressions</p>
          <pre><code data-trim data-noescape>
              var a = 2;
              
              (function foo(){
              
                var a = 3;
                console.log( a ); // 3
              
              })();
              
              console.log( a ); // 2
              </code></pre>

          <aside class="notes">
            К счастью в JS есть решение для обоих проблем. Мы оборачиваем объявление функции в скобки и сразу вызываем ее. Более того,
            имя функции теперь доступно только внутри ее тела и недоступно во внешней области видимости. Такой подход очеьн
            распрастранен и имеет называние - IIFE (Мгновенно вызываемое функциональное выражение).
          </aside>
        </section>

        <section>
          <p>Function expressions vs. Function declarations</p>
          <pre><code data-trim data-noescape>
              /* FUNCTION DECLARATION */
              function foo() {
                console.log("I'm function declaration");
              }

              /* FUNCTION EXPRESSIONS */
              var x = function () {
                console.log('I'm an anonymous function expression')
              }
              
              var y = function doMagic () {
                console.log('I'm a named function expression')
              }
              
              (function () {
                console.log('I'm a self-invoking function expression')
              })()
              
              (function doMagic () {
                console.log('I'm a named self-invoking function expression')
              })()
              
              setTimeout(function () {
                console.log('I'm also an anonymous function expression)
              }, 1000);
              
              setTimeout(function timeoutHandler () {
                console.log('I'm also a named function expression)
              }, 1000);
              </code></pre>

          <aside class="notes">
            До этого мы исползовали только объявления функций, а теперь появилось функциональное выражение. Легче всего различить их
            следующим образом. Если само слово function стоит самым первым в утверждении, то это объявление, в противном
            случае это выражение.
          </aside>
        </section>

        <section>
          <h4>Anonymous vs. Named</h4>
          <pre><code data-trim data-noescape>
              setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
                console.log( "I waited 1 second!" );
              }, 1000 );
              </code></pre>

          <aside class="notes">
            Выражения могут иметь имя, а могут и не иметь его. И хотя кажется, что удобнее не использовать имя, раз оно излешне, именование
            функции дает некоторые преимущества. Мы сможем видеть имя функции в стеке вызовов, что упрощает отладку. Иногда
            нам все же нужно вызвать функцию по имени. Например для создания рекурсии или при отписке от слушания события,
            и именем мы сможем сделать это без хаков (Хак - argument.callee). И последнее, именованая функция улучшает читаемость
            кода. Поэтому лучше всегда именовать функции, чтобы получить все эти преимущества.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section data-markdown>

          <textarea data-template>
          ## Blocks As Scopes
          - `with`
          - `try/catch`
            ```
              try {
                undefined(); // illegal operation to force an exception!
              }
              catch (err) {
                console.log( err ); // works!
              }

              console.log( err ); // ReferenceError: `err` not found
            ```
          - `let & const`

            Note: Хотя в JS нет блочной области видимости, как в во многих других языках, есть механизмы, которые все же позволяют его сэмулировать.
            Основной смысл использования блочной области видимости такой же как и функциональной. Оставлять переменные приватными
            для участка кода, в котором они используются и скрывать их от кода из внешних областей видимости. До спецификации
            ES6 блочный скоуп можно было реализовать путями, которые многие назвали бы хаками. Первый способ это использования
            ключевого слова with, который, как я уже говорил, создает область видимости из объекта переданного в него. Но
            мы уже решили, что использовать его не стоит. Еще один способ малоизвестный это `catch` в блоке `try/catch`. 
            И эти два способа единственное, что было до спецификации ES6, в которой появились ключевые слова const и let
          </textarea>
        </section>

        <section>
          <h2>let, const</h2>
          <pre><code data-trim data-noescape>
              var foo = true;
              
              if (foo) {
                let bar = foo * 2;
                bar = something( bar );
                console.log( bar );
              }
              
              console.log( bar ); // ReferenceError
              </code></pre>

          <aside class="notes">
            Это два альтернативных способа объявления переменных, наряду с var. Эти ключевые слова прикрепляют объявления переменных
            к скоупу любого блока (чаще всего пара фигурных скобок), их содержащего. Другими словами они захватывают любой
            блочный скоуп для своего объявления переменной. Разница между let и const состоит в том, что const объевляет
            неизменяемую переменную или константу. Попытка изменить ее в будущем приведет к ошибки. Но нельзя менять только
            значения. Если значение объект, то можно менят ьего свойства. Также let используется в циклах, но мы вернемся
            к этому при обсуждении замыканий.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section data-markdown>

          <textarea data-template>
            ## Hoisting
            `var a = 2;` <!-- .element: class="fragment" -->
            `var a & a = 2` <!-- .element: class="fragment" -->

            Note: Кажется, что код в JS интерпритируется строка за строкой снизу вверх. Но это правда только отчасти. 
            1. Вместо того, чтобы воспринимать это утверждение как одно целое, движок JS видит его как два различных
            2. Объявление переменной происходит сначала во время компиляции. А присвоение во время выполнения программы Движком.
          </textarea>
        </section>

        <section>
          <pre><code data-trim data-noescape>
            a = 2;
            
            var a;
            
            console.log( a );
          </code></pre>

          <pre><code data-trim data-noescape>
            console.log( a );
            
            var a = 2;
          </code></pre>

          <aside class="notes">
            Это ведет к тому, что объявления переменных внутри области видимости, вне зависимости от того, где они находятся, обрабатываются
            до выполнения кода. Это ведет к тому, что объявления переносятся наверх области видимости, что и называется hoisting
            или всплытие переменных.
          </aside>
        </section>

        <section>
          <h2>Functions First</h2>
          <pre><code data-trim data-noescape>
            foo(); // 1
            
            var foo;
            
            function foo() {
              console.log( 1 );
            }
            
            foo = function() {
              console.log( 2 );
            };
          </code></pre>

          <pre><code data-trim data-noescape>
            foo(); // not ReferenceError, but TypeError!
            
            var foo = function bar() {
              // ...
            };
          </code></pre>

          <aside class="notes">
            Причем функции всплывают первыми вместе со своим значением. Таким образом их можно вызвать до их объявления. Но функциональные
            выражения не всплывают. В данном случае ошибка TypeError потому что объявление переменной всплыло, но ее значение
            undefined. Также повторные объявления функций перезаписывают друг друга и с этим нужно быть осторожными.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Closure</h2>
          <p>Замыкание это когда функция запоминает и имеет доступ к своей лексической области видимости, даже если она была
            вызвана вне этой области.</p>

          <aside class="notes">
            Хотя кажется, что замыкания это какая-то сложная концепция, которая доступна для понимания лишь немногим, на самом деле мы
            используем ее постоянно и она связана с понятием лексической области видимости, о которой я говорил и которая
            задается в момент написания кода.
          </aside>
        </section>

        <section>
          <h2>Creating a closure</h2>
          <pre><code data-trim data-noescape>
                function getTomatoes() {
                  var numberOfTomatoes = 22;
                
                  function garden() { 
                    ('There are ' + numberOfTomatoes + ' tomatoes in the garden');
                  }
                  
                  garden();
                }
                
                getTomatoes() // --> There are 22 tomatoes in the garden
              </code></pre>

          <aside class="notes">
            В данном примере создается замыкание при вызове функции garden. Эта функция имеет замыкание на область видимости функции
            getTomatoes и всех областей видимости выше. Но из определения замыкания мы знаем, что функция имеет доступ к
            лексической области видимости даже если она была вызвана вне этой области. То есть здесь мы просто создаем замыкание,
            но не используем всю его силу.
          </aside>
        </section>

        <section>
          <h2>Exercising a closure</h2>
          <pre><code data-trim data-noescape>
                function getTomatoes() {
                  var numberOfTomatoes = 22;
                
                  return function garden() {
                    console.log('There are ' + numberOfFairies + ' tomatoes in the garden');
                  }
                }
                
                var gardenMagic = getTomatoes() 
                
                gardenMagic(); // --> There are 22 tomatoes in the garden
            </code></pre>

          <aside class="notes">
            Но если мы перепишем пример таким образом, то увидем всю мощь замыканий в действии. Когда мы вызывает функцию gardenMagic,
            мы на самом деле вызываем функцию garden, которая вернулась при вызове getTomatoes. Таким образом функция garden
            вызывается вне совей лексической области видимости и тем не менее она запомнила эту область видимости, в которой
            находится переменная numberOfTomatoes и имеет к ней доступ. В итоге в консоль выводится нужное сообщение. Никакой
            черной магии, только правила лексической области видимости в действии.
          </aside>
        </section>

        <section>
          <h2>Canonical loop example</h2>
          <pre><code data-trim data-noescape>
                for (var i=1; i<=5; i++) {
                  setTimeout( function timer(){
                    console.log( i );
                  }, i*1000 );
                }
            </code></pre>

          <aside class="notes">
            Еще одним классическим примером для демонстрации замыкания является цикл с таймером внутри. Кажется, что в консоль будут
            выводится числа от 1 до 5 последовательно с интервалом в минуту. Но на самом деле в консоль выведется число 6
            пять раз. Число 6, потому что после завершения цикла значение i будет равно 6 (так как именно при этмо значение
            цикл остановится). Далее из-за event-loop, который мы сегодня не обсуждаем, все таймеры выполнятся после завершения
            цикла. И получается, что все функции timer имееют в замыкании одну и ту же переменную i в глобальной области
            видимости. (Функция timer вызывается вне своей лексической области видимости, поэтому имеет место замыкание).
          </aside>
        </section>

        <section>
          <h2>IIFE solution</h2>
          <pre><code data-trim data-noescape>
                for (var i=1; i<=5; i++) {
                  (function(){
                    var j = i;
                    setTimeout( function timer(){
                      console.log( j );
                    }, j*1000 );
                  })();
                }
            </code></pre>

          <aside class="notes">
            Чтобы это исправить на нужно создавать новую область видимость на каждую итерацию и объявлять в ней свою переменную. С этим
            легко справляется IIFE.
          </aside>
        </section>

        <section>
          <h2>Block scoping solution</h2>
          <pre><code data-trim data-noescape>
                for (let i=1; i<=5; i++) {
                  setTimeout( function timer(){
                    console.log( i );
                  }, i*1000 );
                }
            </code></pre>

          <aside class="notes">
            Мы можем пойти еще дальше и использовать новые возможности ES6. Объявляя переменную i через let, на каждую итерацию будет
            создаватся блочный скоуп и каждый timer будет замыкать и иметь доступ к нужной ему переменной i.
          </aside>
        </section>

        <section>
          <h2>Module Pattern</h2>
          <pre><code data-trim data-noescape>
              function myModule () {
                var greeting = "hello";
              
                function sayGreeting () { // closes over the private scope of myModule
                  console.log(greeting);
                };
              
                return {
                  sayGreeting: sayGreeting
                };
              }
              
              var mod = myModule(); // creates an instance of myModule
              
              mod.sayGreeting(); // exercises the closure and logs hello
          </code></pre>

          <aside class="notes">
            И последний пример использования замыканий это паттерн Модуль. Для создания модуля нужны две вещи. Функция-обертка (myModule)
            создающая замыкающую область видимости при вызове и она должна вовращать ссылку хотя бы на одну внутренную по
            отношению к ней функцию (sayGreeting) - API, котороя будет иметь замыкание над внутренней приватной областью
            видимости функции-обертки. Таким образом мы не засоряем глобальную область видимости лишними объявлениями и следуем
            уже известному нам принципу наименьшей привиллегии. Современные библиотеки JS, а также пакетные менеджеры работающие
            с ними используются в своей основе этот паттерн с различными вариациями, что позволяет создавать большие программы
            со множеством зависимостей от библиотек и не переживать из-за коллизии имен переменных.
          </aside>
        </section>

      </section>

      <section data-background-image="img/review.jpg">
        <h1>Review</h1>

        <p class="fragment fade-up">
          Scope
        </p>
        <p class="fragment fade-up">
          Lexical Scope
        </p>
        <p class="fragment fade-up">
          Hoisting
        </p>
        <p class="fragment fade-up">
          Closure
        </p>
        <p class="fragment fade-up">
          Module Pattern
        </p>

        <aside class="notes">
          1. Итак область видимости это набор, которые определяют как и где искать переменную. 2. Лексическая область видимости задается
          во время написания программы в отличии от динамической. В JS основным инструментом для создания лексической области
          видимости являются функции. И блочной области видимости как таковой не существует, все же есть возможность ее создать.
          3. Всплытие переменных происходит на этапе компиляции. До выполнения кода компилятор присваивает в каждую область
          видимости объявленные в них переменные и функции. Таким образом можно сказать, что они всплывают. 4. Замыкание
          это когда функция запоминает и имеет доступ к своей лексической области видимости, даже когда она вызвана вне ее
          пределов. 5. Одним из полезных применений замыканий является паттерн модуль, который прячет в себе приватные детали
          программы и предоствавляет только необходимое API для работы с ней.
        </aside>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [{
          src: 'plugin/markdown/marked.js'
        },
        {
          src: 'plugin/markdown/markdown.js'
        },
        {
          src: 'plugin/notes/notes.js',
          async: true
        },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });

    Reveal.configure({
      slideNumber: true
    });
  </script>
</body>

</html>