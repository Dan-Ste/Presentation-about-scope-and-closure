<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <style>
    .reveal pre code {
      max-height: 550px;
    }

    .text-shadow {
      text-shadow: 4px 6px 7px rgba(0, 0, 0, 0.6) !important;
    }
  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Scope <br>&<br> closures</h1>
      </section>

      <!-- Vertical slides -->
      <section>
        <section data-markdown>

          <textarea data-template>
            ### Область видимости
            Набор правил, которые определяют где и как искать переменную по ее имени <!-- .element: class="fragment" -->
            
            Область программы, в пределах которой имя некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение <!-- .element: class="fragment" -->

            Note: Возможность хранить значения в переменных, а впоследствии получать эти значения - одна из фундаментальных парадигм почти
            всех языков программирования. Мы называем это состоянием программы. И без этого программы были бы не очень интересны и полезны,
            хотя они бы и выполняли какие-то действия. 
            Но где эти переменные хранятся в программе? И как наша программа находит
            их, когда они ей нужны? -> Набор правил которые определяют где и как искать переменные мы называем областью видимости.
            -> Вообще у области видимости есть множество определений и вот еще одно из более строгих.
          </textarea>

        </section>

        <section data-markdown>

          <textarea data-template>
            ### Зачем нужны области видимости?

            Принцип наименьшей привилегии <!-- .element: class="fragment" -->

            Избежание коллизий имен переменных <!-- .element: class="fragment" -->

            Note: Зачем нужны области видимости? 
            Во первых, они позволяют изолировать переменные, что соответствует принципу наименьшей привелегии, 
            также называемого принципом наименьшего влияния или воздейстия. В соответствии с этим принципом дизайна, программа должна давать
            доступ только к тому, что необходимо и скрывать все остальное. 
            Во вторых они позволяют избежать коллизий или столкновений между двумя переменными с одинаковыми именами, но предназначенными для разного использования.
            Такие коллизии приводят к непреднамеренной перезаписи значений подобных переменных. 
            Хорошим примером коллизий и несоблюдения принципа наименьшей привилегии может служить добавление множества различных библиотек в программу, 
            в которых переменные и функции не изолированны должным образом и соответственно могут конфликтовать с переменными из нашей программы или из других библиотек.
          </textarea>

        </section>

        <section>
          <p>Как переменные попадают в области видимости?</p>
          <img src="img/Compiler_time.png">

          <aside class="notes">
            Как переменные попадают в области видимости? JavaScript компилируемый язык, но исполняется он сразу после компиляции. Так
            вот во время компиляции, но перед тем, как сгенерировать код для выполнения Движком, компилятор привязывает переменные
            к областям видимости в которых они были объявлены. В данном случае была объявлена переменная 'a' и привязана
            к глобальной области видимости.
          </aside>
        </section>

        <section>
          <p>Как идентификаторы находятся в области видимости?</p>
          <p class="fragment fade-up">LHS = RHS</p>
          <p class="fragment fade-up">LHS: &nbsp;<code>var a = 2;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>var a = b + c;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>console.log(a)</code></p>

          <aside class="notes">
            После этого генерируется код и исполняется Движком. Когда Движок наталкивается на переменную он ищет ее в скоупе. Поиск может
            осуществляться по двум разным правилам. -> Левосторонний (left hand side) и правосторонний поиск (right hand
            side). Но стороны относительно чего? Относительно оператора присваивания. Но вообще правосторонний поиск не всегда
            связан с оператором присваивания. Можно сказать он не-левосторонний. -> То есть левосторонний поиск осуществляется
            с целью присвоения значения в переменную, -> а правосторонний для возвращения значения переменной.
            </br>
          </aside>
        </section>

        <section>
          <p>Example</p>
          <pre><code data-trim data-noescape>
              function foo(a) {
                var b = a;
                return a + b;
              }
              
              var c = foo( 2 );
          </code></pre>

          <aside class="notes">
            Чтобы понять это лучше, давайте рассмотрим пример. В этом примере есть 3 LHS - 'var c' (объявление переменной c), 'a = 2'
            (а также скрытое присвоение значения аргументу a функции) и 'var b'. А также 4 RHS - 'foo(..)', '= a' , 'a +',
            '+ b'
          </aside>
        </section>

        <section data-background-image="img/building.jpg">
          <p class="text-shadow">Nested Scopes</p>

          <!-- TODO: поменять картинку -->
          <img width="600" height="370" src="img/lexical_scope.png" alt="lexical scope">

          <aside class="notes">
            В предыдущих примерах код был написан в глобальной области видимости, но областей видимости в программе обычно бывает множество
            и так же как функции или блоки могут быть вложенны в другие блоки или функции, области видимости вложенны в другие
            области видимости. И если переменная не была найдена в текущей области видимости, то движок будет искать ее во
            внешних областях видимости, пока не доберется до самой верхней, называемой глобальной. Хорошой метафорой может
            служить многоэтажное здание, в котором текущая область видимости это первый этаж и если мы не найдем переменную
            на этом этаже, то будем подниматься выше по этажам ищя ее, вплоть до последнего этажа, который и является глобальной
            областью видимости. В данном примере переменной b нет в области видимости фунции foo, поэтому Движок ищет (с
            помощью правостороеннего поиска, так как мы ищем переменную с целью вернуть ее значение) и находит ее в глобальной
            области видимости.
          </aside>
        </section>

        <section>
          <h5>Errors ⛔️</h5>
          <p class="fragment fade-up">RHS => <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up">LHS => leaked global variable</p>
          <p class="fragment fade-up">LHS + <code>'strict mode'</code>=> <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up"><code>"don't call me"()</code>=> <code><mark>TypeError</mark></code></p>

          <aside class="notes">
            Почему важен тип поиска переменной? Потому что эти два типа поиска ведут себя по разному в случае ошибки. Если переменная
            не была объявлена и не найдена ни в одной из верхних областей видимости, то в случае правостороннего поиска(RHS)
            это приведет к ошибки 'ReferenceError'. В случае левостороннего поиска (LHS) это приведет к объявлению переменной
            в глобальной области видимости. Это может привести к проблемам, которые сложно отлаживать. Чтобы застраховать
            нас от подобного поведения в ES5 была введена директива strict mode, которая ужесточает правила выполнения кода
            и в данном случае не даст создать переменную в глобальной области видимости, а закончит выполнение программы
            с ошибкой 'ReferenceError'. Если правосторонний поиск выполнился успешно, но мы попытались сделать с полученным
            значением что-то недопустимое, например вызвать как функцию значение не являющееся ей или обратились к свойсвам
            null или undefined, как будто-то они объекты, то мы получим ошибку TypeError и программа также прекратит выполнение.
            То есть понимая как ошибки выполнения связаны с типом поиска, мы можем легче находить и устранять баги.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h5>Типы Областей Видимости</h5>
          <p>Lexical scope - ✍🏻 write-time</p>
          <p>Dynamyc scope - 🚀 runtime</p>

          <aside class="notes">
            JavaScript имеет лексическую область видимости. Это значит, что она основана на том, где переменные и блоки областей видимости
            были написаны самим автором кода. В противоположность этому существует концепция динамической области видимости.
            При таком подходе, не важно где автор написал функцию, а важно откуда она была вызвана во время исполнения кода.
            Такой подход используетмся например в bash скриптах.
          </aside>
        </section>

        <section>
          <h4>Cheating lexical 🚨</h4>
          <p class="fragment fade-up"><code>eval</code></p>
          <p class="fragment fade-up"><code>with</code></p>

          <aside class="notes">
            Но существуют способы обмануть лексическую область видимости. Это можно сделать с помощью -> функции eval или -> ключевого
            слова with
          </aside>
        </section>

        <section>
          <p>Функция<code> eval</code></p>
          <pre><code data-trim data-noescape>
            function foo(str, a) {
              eval( str ); // cheating!
              console.log( a, b );
            }
            
            var b = 2;
            
            foo("var b = 3;", 1); // 1 3
            </code></pre>

          <aside class="notes">
            Eval позволяет выполнить сроку кода, в которой может быть одна или несколько объявлений (переменных или функций). Строку
            кода конечно можно собирать динамически, а не использовать фиксированный литерал, как в этом примере. Таким образом
            в этом примере, Движок как обычно осуществляет поиск переменной в области видимости, не зная, что она была взломана
            и находит ту, что появилась внутри функции foo динамически, а не ту, кототую он должен был найти в глобальной
            области видимости по обычным правилам лексической области видимости. Но мы может избежать этого - директива 'strict
            mode' снова приходит на помощь и не позволяет модифицировать область видимости в которой была исполнена eval.
          </aside>
        </section>

        <section>
          <p>Ключевое слово<code> with</code></p>
          <pre><code data-trim data-noescape>
            var obj = {
              a: 1,
              b: 2,
              c: 3
            };
            
            // дооолго писать
            obj.a = 2;
            obj.b = 3;
            obj.c = 4;
            
            // норм
            with (obj) {
              a = 3;
              b = 4;
              c = 5;
            }
            </code></pre>

          <aside class="notes">
            Второй способ это ключевое слово with. Можно сказать, что with используются для короткой записи переопределения свойств объекта.
            Но под капотом происходит кое-что интересное и опасное.
          </aside>
        </section>

        <section>
          <h4><code>with</code></h4>
          <pre><code data-trim data-noescape>
            function foo(obj) {
              with(obj) {
                a = 2;
              }
            }
            
            var o1 = {
              a: 3
            };
            
            var o2 = {
              b: 3
            };
            
            foo( o1 );
            console.log( o1.a ); // 2
            
            foo( o2 );
            console.log( o2.a ); // undefined
            console.log( a ); // 2 -- Упс, глобальная переменная!
            </code></pre>

          <aside class="notes">
            Происходит следующее. У нас есть два объекта "o1" и "o2". У одного есть свойство a, а у другого его нет. Они передаются в
            функцию, где используются с ключевым словом with. Внутри блока with у нас происходит левосторонний поиск для
            переменной "а" и присвоение в нее значения "2". Но в итоге у объекта "o2" свойство "a" равно undefined, зато
            в глобальной области видимости у идентификатора "a" теперь есть значение 2. Это происходит потому что with использует
            переданный в него объект как совершенно новую лексическую область видимости, созданную налету. А свойства этого
            объекта считаются идентификаторами объявленными в этой области видимости. Таким образом для второго объекта присвоение
            в свойство "а" значения "2" не происходит, потому что в нем (если рассматривать его как область видимости) нет
            такой переменной и далее осуществляется привычный нам левосторонний поиск по областям видимости, который доходит
            до глобальной области видимости. А так как в глобальной области видимости тоже нет такой переменной, то она объявляется
            там и в нее присваевается значение "2". Но как я уже говорил директива strict mode дожна защитить нас он такого
            объявления переменной в глобальной области видимости. Но более того, эта директива вообще не разрешает использовать
            with в коде. Так что можно считать его deprecated, то есть устаревшим.
          </aside>
        </section>

        <section data-background-image="img/stop.jpg">
          <h3 class="text-shadow">Never use <br><code>with</code> & <code>eval</code>!</h3>

        </section>
        <aside class="notes">
          Почему это плохо? Ну во первых эти инструменты очевидно ухушают чтение кода - делают его сложным для понимания, но более
          того они сильно влияют на производительность. Как я уже говорил во время компиляции переменные присваеваются в
          области видимости, это ускоряет поиск этих переменных во время непостредственного исполнения кода, то есть таким
          образом осуществляется его оптимизация. И так как Движок не может знать какую строку мы передадим в "eval" или
          с каким объектом мы вызовем "with", то есть как это повлияет на области видимости, то он не делает вообще никаких
          оптимизаций. Что очевидно ведет медленному выполнению кода. Поэтому никогда не стоит использовать eval и with.
        </aside>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h4>Функции как области видимости</h4>

          <aside class="notes">
            В JavaScript области видимости основаны на функциях. Мы часто сначала объявляем функцию, а затем пишем в ней код. Но конечно
            можно поступать и наоборот, брать кусок кода и оборачивать его в функцию, скрывая таким образом переменные внутри
            функции и делая их недоступными за ее пределами. Такой подход использования функции и соотвественно областей
            видимости дает нам несколько преимуществ. ->
          </aside>
        </section>

        <section>
          <p>Прячем переменные</p>
          <pre><code data-trim data-noescape>
              var a = 2;
              
              function foo() {
              
                var a = 3;
                console.log( a ); // 3
              
              }
              foo();
              
              console.log( a ); // 2
              </code></pre>

          <aside class="notes">
            Итак, в данном примере мы используем функцию foo, чтобы спрятать в ней переменную "а". И хотя переменная с таким же именем
            также имеется в глобальной области видимости наша спрятаная переменная не влияет на нее. И казалось бы все хорошоо,
            мы этого и добивались, но здесь есть несколько недостатков. Во первых мы объявили именованную функцию и ее имя
            также попадает в глобальную область видимости, загрязняя ее. А во вторых чтобы код внутри функции исполнился,
            нам ее нужно вызвать.
          </aside>
        </section>

        <section>
          <h4>IIFE</h4>
          <p>Immediately Invoked Function Expressions</p>
          <pre><code data-trim data-noescape>
              var a = 2;
              
              (function foo(){
              
                var a = 3;
                console.log( a ); // 3
              
              })();
              
              console.log( a ); // 2
              </code></pre>

          <aside class="notes">
            В общем мы можем лучше. И для этого существует такая штука, как немедленно вызываемые функциональные выражения или сокращенно
            от английского IIFE. Мы оборачиваем объявление функции в скобки и сразу вызываем эту обертку. То есть функция
            выполняется сразу после объявления. Теперь имя функции не попадает в глобальную область видимости и доступно
            только внутри нее. Ну и конечно нам теперь не нужно ее вызывать отдельно.
          </aside>
        </section>

        <section>
          <p>Function expressions vs. Function declarations</p>
          <pre><code data-trim data-noescape>
              /* FUNCTION DECLARATION */
              function foo() {
                console.log("I'm function declaration");
              }

              /* FUNCTION EXPRESSIONS */
              var x = function() {
                console.log('I'm an anonymous function expression')
              }
              
              var y = function doMagic() {
                console.log('I'm a named function expression')
              }
              
              (function() {
                console.log('I'm a self-invoking function expression')
              })()
              
              (function doMagic() {
                console.log('I'm a named self-invoking function expression')
              })()
              
              setTimeout(function() {
                console.log('I'm also an anonymous function expression)
              }, 1000);
              
              setTimeout(function timeoutHandler() {
                console.log('I'm also a named function expression)
              }, 1000);
              </code></pre>

          <aside class="notes">
            Как вы заметили IIFE это функциональное выражение, а до этого мы использовали объявления функций. В чем же разница? Легче
            всего различать их следующим образом. Если ключевое слово function стоит самым первым в утверждении, то это объявление,
            в противном случае это выражение. Как видно вариантов выражений много и это еще не все.
          </aside>
        </section>

        <section>
          <p>Anonymous vs. Named</p>
          <pre><code data-trim data-noescape>
              // Именованная функция
              setTimeout( function timeoutHandler(){
                console.log( "I waited 1 second!" );
              }, 1000 );

              // Функция без имени
              setTimeout( function(){
                console.log( "I waited 1 second!" );
              }, 1000 );
              </code></pre>
          <p class="fragment fade-up">Почему лучше всегда именовать функциональные выражения?</p>
          <ol>
            <li class="fragment fade-up">Упрощает отладку</li>
            <li class="fragment fade-up">Вызов по имени</li>
            <li class="fragment fade-up">Улучшает читаемость кода</li>
          </ol>

          <aside class="notes">
            Иакже функциональные выражения могут быть именованными, а могут не иметь имени. И хотя кажется, что удобнее не использовать
            имя, раз его можно не писать, -> именование функций дает некоторые преимущества. -> Во первых мы сможем видеть
            имя функции в стеке вызовов, что упрощает отладку. -> Во вторых нам иногда все же нужно вызвать функцию по имени.
            Например для создания рекурсии или при отписке от слушания события на которая функция была подписана. Без имени
            это тоже можно сделать через arggument.callee но это считается плохой практикой. -> И последнее - именованная
            функция улучшает читаемость кода, а это всегда хорошо. Поэтому лучше всегда именовать функциональные выражения,
            чтобы получить все эти преимущества. Это что касается функций как областей видимости.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section data-markdown>

          <textarea data-template>
          #### Блочная область видимости
          - `with`
          - `try/catch`
            ```
              try {
                undefined(); // illegal operation to force an exception!
              }
              catch (err) {
                console.log( err ); // works!
              }

              console.log( err ); // ReferenceError: `err` not found
            ```
          - `let & const`

            Note: Но как известно во многих языках программирования существует блочная область видимости. Блок, это все что заключено между фигурными скобками.
            Но к сожалению в JavaScript блочной области видимости как таковой не существует. 
            Но все же есть способы ее получить.
            Основной смысл использования блочной области видимости такой же как и у функциональной. Оставлять переменные приватными
            для участка кода, в котором они используются и скрывать их от кода из внешних областей видимости. 
            До спецификации ES6 блочные области видимости можно было реализовать путями, которые многие назвали бы хаками, поэтому это было не очень популярное занятие.
            Первый способ это использования ключевого слова with, корое мы уже обсуждали Но мы уже решили, что его не стоит использовать, поэтому и говорить тут нечего. 
            Еще один малоизвестный способ это блок `catch` в связке `try/catch`. Ошибка попадающая в него изолированна в своей области видимости и недоступна для внешних.
            И эти два способа единственное, что было до спецификации ES6, пока не появились ключевые слова let и const. Вот на них мы и остановимся немного подробнее.
          </textarea>
        </section>

        <section>
          <h4>let, const</h4>
          <pre><code data-trim data-noescape>
              var foo = true;
              
              if (foo) {
                let bar = foo * 2;
                bar = something( bar );
                console.log( bar );
              }
              
              console.log( bar ); // ReferenceError
              </code></pre>

          <aside class="notes">
            Собственно это два альтернативных способа объявления переменных, наряду с известным нам var. Эти ключевые слова прикрепляют
            объявления переменных к области видимости любого блока (то есть паре фигурных скобок), в котором они объявлены.
            Грубо говоря при таком объявлении переменных, блоки ведут себя как функции, изолируя переменные. Разница между
            let и const состоит в том, что const объявляет неизменяемую переменную или константу. Попытка изменить ее в будущем
            приведет к ошибки. Но нельзя менять только значения переменной. Если значение объект, то можно поменять его свойства,
            поэтому нужно быть осторожнее. Также let используется в циклах, но к этому еще вернемся.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section data-markdown>

          <textarea data-template>
            ## Hoisting
            `var a = 2;` <!-- .element: class="fragment" -->
            `var a & a = 2` <!-- .element: class="fragment" -->

            Note: Кажется, что код в JS интерпритируется строка за строкой снизу вверх. Но это правда только отчасти. 
            1. Вместо того, чтобы воспринимать это утверждение как одно целое, движок JS видит его как два различных
            2. Объявление переменной происходит сначала во время компиляции. А присвоение во время выполнения программы Движком.
          </textarea>
        </section>

        <section>
          <pre><code data-trim data-noescape>
            a = 2;
            
            var a;
            
            console.log( a );
          </code></pre>

          <pre><code data-trim data-noescape>
            console.log( a );
            
            var a = 2;
          </code></pre>

          <aside class="notes">
            Это ведет к тому, что объявления переменных внутри области видимости, вне зависимости от того, где они находятся, обрабатываются
            до выполнения кода. Это ведет к тому, что объявления переносятся наверх области видимости, что и называется hoisting
            или всплытие переменных.
          </aside>
        </section>

        <section>
          <h2>Functions First</h2>
          <pre><code data-trim data-noescape>
            foo(); // 1
            
            var foo;
            
            function foo() {
              console.log( 1 );
            }
            
            foo = function() {
              console.log( 2 );
            };
          </code></pre>

          <pre><code data-trim data-noescape>
            foo(); // not ReferenceError, but TypeError!
            
            var foo = function bar() {
              // ...
            };
          </code></pre>

          <aside class="notes">
            Причем функции всплывают первыми вместе со своим значением. Таким образом их можно вызвать до их объявления. Но функциональные
            выражения не всплывают. В данном случае ошибка TypeError потому что объявление переменной всплыло, но ее значение
            undefined. Также повторные объявления функций перезаписывают друг друга и с этим нужно быть осторожными.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Closure</h2>
          <p>Замыкание это когда функция запоминает и имеет доступ к своей лексической области видимости, даже если она была
            вызвана вне этой области.</p>

          <aside class="notes">
            Хотя кажется, что замыкания это какая-то сложная концепция, которая доступна для понимания лишь немногим, на самом деле мы
            используем ее постоянно и она связана с понятием лексической области видимости, о которой я говорил и которая
            задается в момент написания кода.
          </aside>
        </section>

        <section>
          <h2>Creating a closure</h2>
          <pre><code data-trim data-noescape>
                function getTomatoes() {
                  var numberOfTomatoes = 22;
                
                  function garden() { 
                    ('There are ' + numberOfTomatoes + ' tomatoes in the garden');
                  }
                  
                  garden();
                }
                
                getTomatoes() // --> There are 22 tomatoes in the garden
              </code></pre>

          <aside class="notes">
            В данном примере создается замыкание при вызове функции garden. Эта функция имеет замыкание на область видимости функции
            getTomatoes и всех областей видимости выше. Но из определения замыкания мы знаем, что функция имеет доступ к
            лексической области видимости даже если она была вызвана вне этой области. То есть здесь мы просто создаем замыкание,
            но не используем всю его силу.
          </aside>
        </section>

        <section>
          <h2>Exercising a closure</h2>
          <pre><code data-trim data-noescape>
                function getTomatoes() {
                  var numberOfTomatoes = 22;
                
                  return function garden() {
                    console.log('There are ' + numberOfFairies + ' tomatoes in the garden');
                  }
                }
                
                var gardenMagic = getTomatoes() 
                
                gardenMagic(); // --> There are 22 tomatoes in the garden
            </code></pre>

          <aside class="notes">
            Но если мы перепишем пример таким образом, то увидем всю мощь замыканий в действии. Когда мы вызывает функцию gardenMagic,
            мы на самом деле вызываем функцию garden, которая вернулась при вызове getTomatoes. Таким образом функция garden
            вызывается вне совей лексической области видимости и тем не менее она запомнила эту область видимости, в которой
            находится переменная numberOfTomatoes и имеет к ней доступ. В итоге в консоль выводится нужное сообщение. Никакой
            черной магии, только правила лексической области видимости в действии.
          </aside>
        </section>

        <section>
          <h2>Canonical loop example</h2>
          <pre><code data-trim data-noescape>
                for (var i=1; i<=5; i++) {
                  setTimeout( function timer(){
                    console.log( i );
                  }, i*1000 );
                }
            </code></pre>

          <aside class="notes">
            Еще одним классическим примером для демонстрации замыкания является цикл с таймером внутри. Кажется, что в консоль будут
            выводится числа от 1 до 5 последовательно с интервалом в минуту. Но на самом деле в консоль выведется число 6
            пять раз. Число 6, потому что после завершения цикла значение i будет равно 6 (так как именно при этмо значение
            цикл остановится). Далее из-за event-loop, который мы сегодня не обсуждаем, все таймеры выполнятся после завершения
            цикла. И получается, что все функции timer имееют в замыкании одну и ту же переменную i в глобальной области
            видимости. (Функция timer вызывается вне своей лексической области видимости, поэтому имеет место замыкание).
          </aside>
        </section>

        <section>
          <h2>IIFE solution</h2>
          <pre><code data-trim data-noescape>
                for (var i=1; i<=5; i++) {
                  (function(){
                    var j = i;
                    setTimeout( function timer(){
                      console.log( j );
                    }, j*1000 );
                  })();
                }
            </code></pre>

          <aside class="notes">
            Чтобы это исправить на нужно создавать новую область видимость на каждую итерацию и объявлять в ней свою переменную. С этим
            легко справляется IIFE.
          </aside>
        </section>

        <section>
          <h2>Block scoping solution</h2>
          <pre><code data-trim data-noescape>
                for (let i=1; i<=5; i++) {
                  setTimeout( function timer(){
                    console.log( i );
                  }, i*1000 );
                }
            </code></pre>

          <aside class="notes">
            Мы можем пойти еще дальше и использовать новые возможности ES6. Объявляя переменную i через let, на каждую итерацию будет
            создаватся блочный скоуп и каждый timer будет замыкать и иметь доступ к нужной ему переменной i.
          </aside>
        </section>

        <section>
          <h2>Module Pattern</h2>
          <pre><code data-trim data-noescape>
              function myModule () {
                var greeting = "hello";
              
                function sayGreeting () { // closes over the private scope of myModule
                  console.log(greeting);
                };
              
                return {
                  sayGreeting: sayGreeting
                };
              }
              
              var mod = myModule(); // creates an instance of myModule
              
              mod.sayGreeting(); // exercises the closure and logs hello
          </code></pre>

          <aside class="notes">
            И последний пример использования замыканий это паттерн Модуль. Для создания модуля нужны две вещи. Функция-обертка (myModule)
            создающая замыкающую область видимости при вызове и она должна вовращать ссылку хотя бы на одну внутренную по
            отношению к ней функцию (sayGreeting) - API, котороя будет иметь замыкание над внутренней приватной областью
            видимости функции-обертки. Таким образом мы не засоряем глобальную область видимости лишними объявлениями и следуем
            уже известному нам принципу наименьшей привиллегии. Современные библиотеки JS, а также пакетные менеджеры работающие
            с ними используются в своей основе этот паттерн с различными вариациями, что позволяет создавать большие программы
            со множеством зависимостей от библиотек и не переживать из-за коллизии имен переменных.
          </aside>
        </section>

      </section>

      <section data-background-image="img/review.jpg">
        <h1>Review</h1>

        <p class="fragment fade-up">
          Scope
        </p>
        <p class="fragment fade-up">
          Lexical Scope
        </p>
        <p class="fragment fade-up">
          Hoisting
        </p>
        <p class="fragment fade-up">
          Closure
        </p>
        <p class="fragment fade-up">
          Module Pattern
        </p>

        <aside class="notes">
          1. Итак область видимости это набор, которые определяют как и где искать переменную. 2. Лексическая область видимости задается
          во время написания программы в отличии от динамической. В JS основным инструментом для создания лексической области
          видимости являются функции. И блочной области видимости как таковой не существует, все же есть возможность ее создать.
          3. Всплытие переменных происходит на этапе компиляции. До выполнения кода компилятор присваивает в каждую область
          видимости объявленные в них переменные и функции. Таким образом можно сказать, что они всплывают. 4. Замыкание
          это когда функция запоминает и имеет доступ к своей лексической области видимости, даже когда она вызвана вне ее
          пределов. 5. Одним из полезных применений замыканий является паттерн модуль, который прячет в себе приватные детали
          программы и предоствавляет только необходимое API для работы с ней.
        </aside>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [{
          src: 'plugin/markdown/marked.js'
        },
        {
          src: 'plugin/markdown/markdown.js'
        },
        {
          src: 'plugin/notes/notes.js',
          async: true
        },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });

    Reveal.configure({
      slideNumber: true
    });
  </script>
</body>

</html>