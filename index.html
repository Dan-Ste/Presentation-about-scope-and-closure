<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Scope <br>&<br> Closures</h1>
      </section>

      <section data-markdown>

        <textarea data-template>
          ## Scope
          Набор правил, которые определяют где и как искать переменную по ее имени <!-- .element: class="fragment" -->
          
          Область программы, в пределах которой идентификатор (имя) некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение <!-- .element: class="fragment" -->

          Note: Возможность хранить значения в переменных, а впоследствии получать эти значения - одна из фундаментальных парадигм почти
          всех языков программирования. Мы называем это состоянием. И без этого программы были бы не очень интересны и полезны,
          хотя они бы и выполняли какие-то действия. Но где эти переменные хранятся в программе? И как наша программа находит
          их, когда они ей нужны? Набор правил которые определяют где и как искать переменные мы называем областью видимости.
        </textarea>

      </section>

      <section>
        <h4>Как идентификаторы попадают в scope?</h4>
        <img src="img/Compiler_time.png">

        <aside class="notes">
          JS комилируется в рантайме. После лексического аналаиза и построения AST, но перед тем, как сгенерировать код для выполнения
          Движком, компилятор привязывает идентификаторы переменных в области видимости в которых они были объявлены. Здесь
          была объявлена переменная 'a' в глобальной области видимости (потому что других нет).
        </aside>
      </section>

      <section>

        <section>
          <h4>Как идентификаторы находятся в SCOPE?</h4>
          <p class="fragment fade-up">LHS = RHS</p>
          <p class="fragment fade-up">LHS: &nbsp;<code>var a = 2;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>var a = b + c;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>console.log(a)</code></p>

          <aside class="notes">
            После этого генерируется код и исполняется Движком. Когда Движок наталкивается на переменную он ищет ее в скоупе. Поиск может
            осуществляться по двум разным правилам. Левосторонний и правосторонний поиск. Стороны относительно чего? Относительно
            оператора присваивания. Но вообще-то правосторонний поиск не всегда связан с оператором присваивания. Можно сказать
            он не-левосторонний. То есть левосторонний поиск осуществляется с целью присвоения в переменную, а правосторонний
            возвращения значения переменной
            </br>
          </aside>
        </section>

        <section>
          <h2>Example</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                var b = a;
                return a + b;
              }
              
              var c = foo( 2 );
          </code></pre>

          <aside class="notes">
            В этом примере есть 3 LHS - 'var c', 'a = 2' (скрытое присвоение в аргументе функции) и 'var b'. А также 4 RHS - 'foo(..)',
            '= a' , 'a +', '+ b'
          </aside>
        </section>

        <section data-background-image="img/building.jpg">
          <h2>Nested Scopes</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                console.log( a + b );
              }
              
              var b = 2;
              
              foo( 2 ); // 4
          </code></pre>

          <aside class="notes">
            Так же как функции или блоки могут быть вложенны в другие блоки или функции, области видимости вложенны в другие области
            видимости. И если переменная не была найдена в текущей области видимости, то движок будет искать ее во внешних
            областях видимости, пока не доберется до самый верхней, называемой глобальной. Хорошой метафорой может служить
            многоэтажное здание, в котором текущая область видимости это первый этаж и если мы не найдем переменную на этом
            этаже, то будем подниматься выше по этажам ищя ее, вплоть до последнего этажа, который является глобальной областью
            видимости. В данном примере переменной b нет в области видимости фунции foo, поэтому Движок ищет и находит ее
            в глобальной области видимости со значением 2. Кстати для ее поиска был применен правосторонний поиск.
          </aside>
        </section>

        <section>
          <h2>Errors</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                console.log( a + b );
                b = a;
              }
              
              foo( 2 );
            </code></pre>
          <p class="fragment fade-up">RHS => <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up">LHS => leaked global variable</p>
          <p class="fragment fade-up">LHS + <code>'strict mode'</code>=> <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up"><code>"don't call me"()</code>=> <code><mark>TypeError</mark></code></p>

          <aside class="notes">
            Зачем нам нужно это знать какой тип поиска был применен? Потому что эти два типа поиска ведут себя по разному, если переменная
            не была объявлена и не найдена ни в одной из областей видимости. В случае RHS это приведет к ошибки 'ReferenceError',
            выброшенной Движком. В случае LHS это приведет к объявлению переменной в глобальной области видимости. Но с директивой
            'strict mode' также к 'ReferenceError'. Если RHS поиск выполнился успешно, но мы попытались сделать с этим значением
            что-то невозможное, например вызвать не функцию как функцию или обратились к свойсвам null или undefined, то
            мы получим ошибку TypeError
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Lexical Scope</h2>
          <img src="img/lexical_scope.png" alt="lexical scope">

          <aside class="notes">
            JS имеет лексическую область видимости. Это значит, что она основано на том, где переменные и блоки областей видимости были
            написаны самим автором кода. Это парсится во время лексческого анализа, поэтому и имеет название лексической
            области видимости.

          </aside>
        </section>

        <section>
          <p>Lexical scope - write-time</p>
          <p>Dynamyc scope - runtime</p>

          <aside class="notes">
            В противоположность этому существует концепция динамической области видимости. При таком подходе, не важно где автор написал
            функцию, а важно откуда она была вызвана во время исполнения кода. Такой подход используетмся например в bash
            скриптах.
          </aside>
        </section>

        <section>
          <h2>Cheating lexical</h2>
          <p class="fragment fade-up"><code>eval</code></p>
          <p class="fragment fade-up"><code>with</code></p>

          <aside class="notes">
            Но в JS существуют способы взломать лексическую область видимости. Это можно сделать с помощью функции eval или ключевого
            слова with
          </aside>
        </section>

        <section>
          <h2>eval</h2>
          TODO: example with eval

          <aside class="notes">
            TODO: What is eval all about?
          </aside>
        </section>

        <section>
          <h2>with</h2>
          TODO: exaple with with (pun intendent)

          <aside class="notes">
            TODO: What is with all about?
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section data-background-image="img/js.jpg">
          <h2>Cheating Lexical Scope</h2>

          <aside class="notes">
            TODO: Есть способоы взломать скоуп
          </aside>
        </section>

        <section>
          <h2>eval</h2>
          <!-- TODO: пример кода с eval -->

          <aside class="notes">
            TODO: Кратко что он делает
          </aside>
        </section>

        <section>
          <h2>with</h2>
          <!-- TODO: пример кода с with -->

          <aside class="notes">
            TODO: Кратко что он делает
          </aside>
        </section>

        <section>
          <h2>Never do this</h2>

          <aside class="notes">
            TODO: Почему это плохо
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Why scope?</h2>

          <aside class="notes">
            TODO: Зачем нужен скоуп?
          </aside>
        </section>

        <section>
          <h2>Principle of Least Privilege</h2>
          <!-- TODO: Пример -->

          <aside class="notes">
            TODO: Что и зачем
          </aside>
        </section>

        <section>
          <h2>Collision Avoidance</h2>
          <!-- TODO: Пример -->

          <aside class="notes">
            TODO: Что и зачем. Тут про глобальное пространство имен
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Functions As Scopes</h2>
          <!-- TODO: Пример с прятаньем в функцию -->

          <aside class="notes">
            TODO: все понятно вроде
          </aside>
        </section>

        <section>
          <h2>IIFE</h2>
          <p>Immediately Invoked Function Expressions</p>
          <!-- TODO: Улучшаем до IIFE -->

          <aside class="notes">
            TODO: Зачем они нужны
          </aside>
        </section>

        <section>
          <h2>Function expressions vs. Function declarations</h2>
          <!-- TODO: Куча примеров функциональных выражений -->

          <aside class="notes">
            TODO: В чем разница
          </aside>
        </section>

        <section>
          <h2>Anonymous vs. Named</h2>
          <!-- TODO: Улучшаем до IIFE -->

          <aside class="notes">
            TODO: Зачем именновать функции
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Blocks As Scopes</h2>
          <p class="fragment fade-up"><code>with</code></p>
          <p class="fragment fade-up"><code>try/catch</code></p>
          <p class="fragment fade-up"><code>let, const</code></p>

          <aside class="notes">
            TODO: Ну вообще то нет такого в JS. Ну почти
          </aside>
        </section>

        <section>
          <h2>let, const</h2>

          <aside class="notes">
            TODO: Примеры. Механика работы
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Hoisting</h2>

          <aside class="notes">
            TODO: Что это?
          </aside>
        </section>

        <section>
          <!-- TODO: примеры -->

          <aside class="notes">
            TODO: объяснения
          </aside>
        </section>

        <section>
          <h2>Functions First</h2>
          <!-- TODO: примеры  -->

          <aside class="notes">
            TODO: Как работает. Объяснения примеров
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Closure</h2>
          <!-- TODO: Определение -->

          <aside class="notes">
            TODO: Навести страху, потом сказать, что все просто
          </aside>
        </section>

        <section>
          <!-- TODO: Простой пример -->

          <aside class="notes">
            TODO: объяснения
          </aside>
        </section>

        <section>
          <!-- TODO: реальные примеры  -->
          <!-- TODO: реальные примеры  -->
          <!-- TODO: реальные примеры  -->

          <aside class="notes">
            TODO: Объяснения примеров
          </aside>
        </section>

        <section>
          <!-- TODO: классический пример с циклом -->

          <aside class="notes">
            TODO: Объяснение
          </aside>
        </section>

        <section>
          <h2>Module Pattern</h2>
          <!-- TODO: определение  -->

          <aside class="notes">
            TODO: Определение. Объяснение
          </aside>
        </section>

        <section>
          <h2>Today And Future Modules</h2>

          <aside class="notes">
            TODO: Объяснение примеров
          </aside>
        </section>

      </section>

      <section data-background-image="img/review.jpg">
        <h1>Review</h1>

        <p class="fragment fade-up">
          Scope
        </p>
        <p class="fragment fade-up">
          Lexical Scope
        </p>
        <p class="fragment fade-up">
          Hoisting
        </p>
        <p class="fragment fade-up">
          Closure
        </p>
        <p class="fragment fade-up">
          Module Pattern
        </p>

        <aside class="notes">
          TODO: Определения, краткий пересказ
        </aside>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [{
          src: 'plugin/markdown/marked.js'
        },
        {
          src: 'plugin/markdown/markdown.js'
        },
        {
          src: 'plugin/notes/notes.js',
          async: true
        },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });

    Reveal.configure({
      slideNumber: true
    });
  </script>
</body>

</html>