<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/atom-one-dark.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <style>
    .reveal pre code {
      max-height: 550px;
    }

    .text-shadow {
      text-shadow: 2px 4px 3px rgba(0, 0, 0, 0.3) !important;
    }
  </style>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <h1>Scope <br>&<br> Closures</h1>
      </section>

      <section data-markdown>

        <textarea data-template>
          ## Scope
          Набор правил, которые определяют где и как искать переменную по ее имени <!-- .element: class="fragment" -->
          
          Область программы, в пределах которой идентификатор (имя) некоторой переменной продолжает быть связанным с этой переменной и возвращать её значение <!-- .element: class="fragment" -->

          Note: Возможность хранить значения в переменных, а впоследствии получать эти значения - одна из фундаментальных парадигм почти
          всех языков программирования. Мы называем это состоянием. И без этого программы были бы не очень интересны и полезны,
          хотя они бы и выполняли какие-то действия. Но где эти переменные хранятся в программе? И как наша программа находит
          их, когда они ей нужны? Набор правил которые определяют где и как искать переменные мы называем областью видимости.
        </textarea>

      </section>

      <section>
        <h4>Как идентификаторы попадают в scope?</h4>
        <img src="img/Compiler_time.png">

        <aside class="notes">
          JS комилируется в рантайме. После лексического аналаиза и построения AST, но перед тем, как сгенерировать код для выполнения
          Движком, компилятор привязывает идентификаторы переменных в области видимости в которых они были объявлены. Здесь
          была объявлена переменная 'a' в глобальной области видимости (потому что других нет).
        </aside>
      </section>

      <section>

        <section>
          <h4>Как идентификаторы находятся в SCOPE?</h4>
          <p class="fragment fade-up">LHS = RHS</p>
          <p class="fragment fade-up">LHS: &nbsp;<code>var a = 2;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>var a = b + c;</code></p>
          <p class="fragment fade-up">RHS: &nbsp;<code>console.log(a)</code></p>

          <aside class="notes">
            После этого генерируется код и исполняется Движком. Когда Движок наталкивается на переменную он ищет ее в скоупе. Поиск может
            осуществляться по двум разным правилам. Левосторонний и правосторонний поиск. Стороны относительно чего? Относительно
            оператора присваивания. Но вообще-то правосторонний поиск не всегда связан с оператором присваивания. Можно сказать
            он не-левосторонний. То есть левосторонний поиск осуществляется с целью присвоения в переменную, а правосторонний
            возвращения значения переменной
            </br>
          </aside>
        </section>

        <section>
          <h2>Example</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                var b = a;
                return a + b;
              }
              
              var c = foo( 2 );
          </code></pre>

          <aside class="notes">
            В этом примере есть 3 LHS - 'var c', 'a = 2' (скрытое присвоение в аргументе функции) и 'var b'. А также 4 RHS - 'foo(..)',
            '= a' , 'a +', '+ b'
          </aside>
        </section>

        <section data-background-image="img/building.jpg">
          <h2>Nested Scopes</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                console.log( a + b );
              }
              
              var b = 2;
              
              foo( 2 ); // 4
          </code></pre>

          <aside class="notes">
            Так же как функции или блоки могут быть вложенны в другие блоки или функции, области видимости вложенны в другие области
            видимости. И если переменная не была найдена в текущей области видимости, то движок будет искать ее во внешних
            областях видимости, пока не доберется до самый верхней, называемой глобальной. Хорошой метафорой может служить
            многоэтажное здание, в котором текущая область видимости это первый этаж и если мы не найдем переменную на этом
            этаже, то будем подниматься выше по этажам ищя ее, вплоть до последнего этажа, который является глобальной областью
            видимости. В данном примере переменной b нет в области видимости фунции foo, поэтому Движок ищет и находит ее
            в глобальной области видимости со значением 2. Кстати для ее поиска был применен правосторонний поиск.
          </aside>
        </section>

        <section>
          <h2>Errors</h2>
          <pre><code data-trim data-noescape>
              function foo(a) {
                console.log( a + b );
                b = a;
              }
              
              foo( 2 );
            </code></pre>
          <p class="fragment fade-up">RHS => <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up">LHS => leaked global variable</p>
          <p class="fragment fade-up">LHS + <code>'strict mode'</code>=> <code><mark>ReferenceError</mark></code></p>
          <p class="fragment fade-up"><code>"don't call me"()</code>=> <code><mark>TypeError</mark></code></p>

          <aside class="notes">
            Зачем нам нужно это знать какой тип поиска был применен? Потому что эти два типа поиска ведут себя по разному, если переменная
            не была объявлена и не найдена ни в одной из областей видимости. В случае RHS это приведет к ошибки 'ReferenceError',
            выброшенной Движком. В случае LHS это приведет к объявлению переменной в глобальной области видимости. Но с директивой
            'strict mode' также к 'ReferenceError'. Если RHS поиск выполнился успешно, но мы попытались сделать с этим значением
            что-то невозможное, например вызвать не функцию как функцию или обратились к свойсвам null или undefined, то
            мы получим ошибку TypeError
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Lexical Scope</h2>
          <img src="img/lexical_scope.png" alt="lexical scope">

          <aside class="notes">
            JS имеет лексическую область видимости. Это значит, что она основано на том, где переменные и блоки областей видимости были
            написаны самим автором кода. Это парсится во время лексческого анализа, поэтому и имеет название лексической
            области видимости.

          </aside>
        </section>

        <section>
          <p>Lexical scope - ✍🏻 write-time</p>
          <p>Dynamyc scope - 🚀 runtime</p>

          <aside class="notes">
            В противоположность этому существует концепция динамической области видимости. При таком подходе, не важно где автор написал
            функцию, а важно откуда она была вызвана во время исполнения кода. Такой подход используетмся например в bash
            скриптах.
          </aside>
        </section>

        <section>
          <h4>Cheating lexical 🚨</h4>
          <p class="fragment fade-up"><code>eval</code></p>
          <p class="fragment fade-up"><code>with</code></p>

          <aside class="notes">
            Но существуют способы взломать лексическую область видимости. Это можно сделать с помощью функции eval или ключевого слова
            with
          </aside>
        </section>

        <section>
          <h2><code>eval</code></h2>
          <pre><code data-trim data-noescape>
            function foo(str, a) {
              eval( str ); // cheating!
              console.log( a, b );
            }
            
            var b = 2;
            
            foo( "var b = 3;", 1 ); // 1 3
            </code></pre>

          <aside class="notes">
            Eval позволяет выполнять сроку с кодом, в которой может быть одно или несколько объявлений (переменных или функций). Строку
            кода конечно можно собирать программно, а не использовать фиксированный литерал, как в этом примере. Таким образом
            в этом снипите кода, Движок как обычно осуществляет поиск переменной в области видимости, не знаю, что она была
            взломана. Также стоит сказать, что директива 'strict mode' не аозволяет модифицировать область видимости в которой
            была исполнена eval.
          </aside>
        </section>

        <section>
          <h4><code>with</code></h4>
          <pre><code data-trim data-noescape>
            var obj = {
              a: 1,
              b: 2,
              c: 3
            };
            
            // долго писать
            obj.a = 2;
            obj.b = 3;
            obj.c = 4;
            
            // норм
            with (obj) {
              a = 3;
              b = 4;
              c = 5;
            }
            </code></pre>

          <aside class="notes">
            Можно сказать, что with используются для короткой записи переопределения свойств объекта. Но под капотом происходит нечто
            интересное.
          </aside>
        </section>

        <section>
          <h4><code>with</code></h4>
          <pre><code data-trim data-noescape>
            function foo(obj) {
              with (obj) {
                a = 2;
              }
            }
            
            var o1 = {
              a: 3
            };
            
            var o2 = {
              b: 3
            };
            
            foo( o1 );
            console.log( o1.a ); // 2
            
            foo( o2 );
            console.log( o2.a ); // undefined
            console.log( a ); // 2 -- Oops, leaked global!
            </code></pre>

          <aside class="notes">
            У нас есть два объекта "o1" и "o2". У одного есть свойство a, а у другого нет. Они передаются в функцию, где вызываются с
            with. Внутри блока with у нас происходит левосторонний поиск для переменной "а" и присвоение в нее значения "2".
            Но в итоге у объекта "o2" свойство "a" равно undefined, зато в глобальной области видимости у идентификатора
            "a" теперь есть значение 2. Это происходит потому что with использует переданный в него объект как совершенно
            новую лексическую область видимости, созданную из неоткуда. А свойства этого объекта считаются идентификаторами
            объявленными в этой области видимости. Таким образом для второго объекта присвоение в свойство "а" значения "2"
            не происходит, потому что в нем (если рассматривать его как область видимости) нет такого идентификатора и далее
            осуществляется привычный нам левосторонний поиск по областям видимости, который доходит до глобальной области
            видимости, так как в области видимости функции тоже нет такого идентификатора, и объявляет там идентификатор
            "а" (ну и затем присваевает в него "2"). При директиве "strict mode" полностью запрещен.
          </aside>
        </section>

        <section data-background-image="img/stop.jpg">
          <h3 class="text-shadow">Never use them</h3>

        </section>
        <aside class="notes">
          Почему это плохо? Простой ответ - производительность. Во время компиляции Движок JS осуществляет ряд оптимизаций, в том числе
          предопределяет где объявлены все переменные и функции. И так как он не может знать какую строку мы передадим в
          "eval" или с каким объектом мы вызовем "with", он не делает вообще никаких оптимизаций. Что очевидно ведет медленному
          выполнению кода. Поэтому никогда не стоит использовать eval и with.
        </aside>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Why scope?</h2>
          <p class="fragment fade-up">Principle of Least Privilege</p>
          <p class="fragment fade-up">Collision Avoidance</p>

          <aside class="notes">
            Для чего вообще нужен такой механизм, как область видимости? В JS область видимости в основном основана на функциях. Мы часто
            сначала объявляем функцию, а затем пишем в ней код. Но конечно можно поступать и наоборот, брать кусок кода и
            оборачивать его в функцию, скрывая таким образом переменные внутри функции и делая их недоступными за ее пределами.
            Такой подход использования скоупа дает нам несколько преимуществ. Первое, это соответствие принципу наименьшей
            привелегии, также называемого принципом наименьшего влияния или воздейстия. В соответсвии с этим принципом дизайн
            API для модуля или объекта должен раскрывать только то, что необходимо и скрывать все остальное. Второе преимущество
            позволяет избежать колизий или столкновений между двумя переменными с одинаковыми идентификаторами, но предназначенными
            для разного использования. Это может вести к непреднамеренной перезаписи значений этих переменных. Хорошим примером
            может служить добавление множества различных библиотек, в которых переменные и функции не спрятаны должным образом
            и соответственно могут перезаписывать друг друга. Чтобы этого не происходило можно использовать паттерн модуль,
            о котором я раскажу немного позже.
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Functions As Scopes</h2>
          <pre><code data-trim data-noescape>
              var a = 2;
              
              function foo() {
              
                var a = 3;
                console.log( a ); // 3
              
              }
              foo();
              
              console.log( a ); // 2
              </code></pre>

          <aside class="notes">
            TODO: все понятно вроде
          </aside>
        </section>

        <section>
          <h2>IIFE</h2>
          <p>Immediately Invoked Function Expressions</p>
          <!-- TODO: Улучшаем до IIFE -->

          <aside class="notes">
            TODO: Зачем они нужны
          </aside>
        </section>

        <section>
          <h2>Function expressions vs. Function declarations</h2>
          <!-- TODO: Куча примеров функциональных выражений -->

          <aside class="notes">
            TODO: В чем разница
          </aside>
        </section>

        <section>
          <h2>Anonymous vs. Named</h2>
          <!-- TODO: Улучшаем до IIFE -->

          <aside class="notes">
            TODO: Зачем именновать функции
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Blocks As Scopes</h2>
          <p class="fragment fade-up"><code>with</code></p>
          <p class="fragment fade-up"><code>try/catch</code></p>
          <p class="fragment fade-up"><code>let, const</code></p>

          <aside class="notes">
            TODO: Ну вообще то нет такого в JS. Ну почти
          </aside>
        </section>

        <section>
          <h2>let, const</h2>

          <aside class="notes">
            TODO: Примеры. Механика работы
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Hoisting</h2>

          <aside class="notes">
            TODO: Что это?
          </aside>
        </section>

        <section>
          <!-- TODO: примеры -->

          <aside class="notes">
            TODO: объяснения
          </aside>
        </section>

        <section>
          <h2>Functions First</h2>
          <!-- TODO: примеры  -->

          <aside class="notes">
            TODO: Как работает. Объяснения примеров
          </aside>
        </section>

      </section>

      <!-- Vertical slides -->
      <section>

        <section>
          <h2>Closure</h2>
          <!-- TODO: Определение -->

          <aside class="notes">
            TODO: Навести страху, потом сказать, что все просто
          </aside>
        </section>

        <section>
          <!-- TODO: Простой пример -->

          <aside class="notes">
            TODO: объяснения
          </aside>
        </section>

        <section>
          <!-- TODO: реальные примеры  -->
          <!-- TODO: реальные примеры  -->
          <!-- TODO: реальные примеры  -->

          <aside class="notes">
            TODO: Объяснения примеров
          </aside>
        </section>

        <section>
          <!-- TODO: классический пример с циклом -->

          <aside class="notes">
            TODO: Объяснение
          </aside>
        </section>

        <section>
          <h2>Module Pattern</h2>
          <!-- TODO: определение  -->

          <aside class="notes">
            TODO: Определение. Объяснение
          </aside>
        </section>

        <section>
          <h2>Today And Future Modules</h2>

          <aside class="notes">
            TODO: Объяснение примеров
          </aside>
        </section>

      </section>

      <section data-background-image="img/review.jpg">
        <h1>Review</h1>

        <p class="fragment fade-up">
          Scope
        </p>
        <p class="fragment fade-up">
          Lexical Scope
        </p>
        <p class="fragment fade-up">
          Hoisting
        </p>
        <p class="fragment fade-up">
          Closure
        </p>
        <p class="fragment fade-up">
          Module Pattern
        </p>

        <aside class="notes">
          TODO: Определения, краткий пересказ
        </aside>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
      dependencies: [{
          src: 'plugin/markdown/marked.js'
        },
        {
          src: 'plugin/markdown/markdown.js'
        },
        {
          src: 'plugin/notes/notes.js',
          async: true
        },
        {
          src: 'plugin/highlight/highlight.js',
          async: true,
          callback: function () {
            hljs.initHighlightingOnLoad();
          }
        }
      ]
    });

    Reveal.configure({
      slideNumber: true
    });
  </script>
</body>

</html>